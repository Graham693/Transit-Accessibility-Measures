---
title: "Travel Time Matrix to Maps"
output: html_notebook
---

## Notebook Purpose

This notebook serves to summarize the entire visualization process going from 
the travel time matrix to the visualizations. That involves the following 
sections:

1) Travel Time Matrix Wrangling
2) Score Computation
3) Isochrone Computation
4) Dataset Wrangling Part II (NA Insertion)
5) Interactive Visualization
6) Map HTML Exports

## 0) Useful Libraries

```{r message=FALSE, warning=FALSE, include=TRUE}
# import custom scoring, cleaning, and visualization functions
source('functions_eff.R')

# wrangling/convenience
library(tidyverse)
library(glue)
library(stringr)
library(sf)
library(data.table)
library(bit64)

# visualization
library(leaflet)
library(mapview); mapviewOptions(platform = 'leafgl')

# For pretty knitting
library(lemon)
knit_print.data.frame <- lemon_print
knit_print.tbl <- lemon_print
knit_print.summary <- lemon_print
```




# 1 Initial data wrangling
```{r}

# Function to calculate efficiency withing 'X' degrees of each block

#import scores
db_prox <- read.csv('../../data/clean/vancouver_Prox.csv', stringsAsFactors = FALSE)
scores_long <- read.csv('../../data/efficiency/initial_scores.csv', stringsAsFactors = FALSE)
origins <- fread(file.path("../../data/clean", "vancouver_db.csv"), stringsAsFactors = FALSE)[, .(id, pop, lat, lon)]

origins$pop <- str_replace_all(origins$pop, ',', '')

# change col types
db_prox[db_prox==".."]<-NA
db_prox[db_prox=="F"]<-NA
db_prox <- data.frame(lapply(db_prox,as.numeric))
scores_long$fromId <- as.factor(scores_long$fromId)
origins$pop <- as.numeric(origins$pop)  
origins$id <- as.factor(origins$id)  
db_prox$id <- as.factor(db_prox$id)
n_origins <- nrow(origins)
paste('Origin Rows: ', n_origins)
```


# 2 Processing efficiency scores
```{r}
  rollingAvg <- function(row){
    mean(filter(scores_func, scores_func$lat <= (as.numeric(row["lat"])+0.005) & scores_func$lat >= (as.numeric(row["lat"])-0.005) & scores_func$lon <= (as.numeric(row["lon"])+0.005) & scores_func$lon >= (as.numeric(row["lon"])-0.005))$eff) 
  }

rollingAvg_prox <- function(row){
  prox_score <- filter(scores_func, scores_func$lat <= (as.numeric(row["lat"])+0.005) & scores_func$lat >= (as.numeric(row["lat"])-0.005) & scores_func$lon <= (as.numeric(row["lon"])+0.005) & scores_func$lon >= (as.numeric(row["lon"])-0.005)) %>% select(9:19) %>% colMeans(na.rm = TRUE) %>% mean()
  if(is.na(prox_score)){
    prox_score <- 0
  }
  return(prox_score)
}


origins_pos <- origins
scores_long_pos <-filter(scores_long,stringr::str_detect(nearest_n, 'all') & stringr::str_detect(weight, 'no'))
scores_pos <- left_join(scores_long_pos, origins_pos, by=c("fromId" = "id"), keep = FALSE)
scores_pos <- left_join(scores_pos, db_prox,  by=c("fromId" = "id"), keep = FALSE, set)


# Calulate initial efficiency for each block
scores_pos$pop_norm_squared <- normalize_vec(scores_pos$pop)


# Create dataframe for each amenity type
scores_prox_gal <- filter(scores_pos,stringr::str_detect(type, 'gallery'))
scores_prox_lib <- filter(scores_pos,stringr::str_detect(type, 'library or archives'))
scores_prox_thea <- filter(scores_pos,stringr::str_detect(type, 'theatre/performance and concert hall'))
scores_prox_mus <- filter(scores_pos,stringr::str_detect(type, 'museum'))

# Create running efficiency scores
scores_prox_score <- data.frame(fromId=factor(),type=factor(),score=numeric(),weight=factor(),nearest_n=factor(),pop=numeric(),lat=numeric(),lon=numeric(),eff=numeric())
df_types_prox <- list(scores_prox_gal,scores_prox_lib,scores_prox_thea,scores_prox_mus)

for(df in df_types_prox){
  scores_func <- df
  df$prox_score <- apply(df,1, rollingAvg_prox)
  scores_prox_score <- rbind(scores_prox_score,df)
}


scores_prox_score$eff <- normalize_vec_nonAbs(scores_prox_score$prox_score - scores_prox_score$score)

# Create dataframe for each amenity type
scores_eff_gal <- filter(scores_prox_score,stringr::str_detect(type, 'gallery'))
scores_eff_lib <- filter(scores_prox_score,stringr::str_detect(type, 'library or archives'))
scores_eff_thea <- filter(scores_prox_score,stringr::str_detect(type, 'theatre/performance and concert hall'))
scores_eff_mus <- filter(scores_prox_score,stringr::str_detect(type, 'museum'))

scores_eff_all <- data.frame(fromId=factor(),type=factor(),score=numeric(),weight=factor(),nearest_n=factor(),pop=numeric(),lat=numeric(),lon=numeric(),eff=numeric())
df_types_eff <- list(scores_eff_gal,scores_eff_lib,scores_eff_thea,scores_eff_mus)

for(df in df_types_eff){
  scores_func <- df
  df$eff_ravg <- normalize_vec_nonAbs(apply(df,1, rollingAvg))
  scores_eff_all <- rbind(scores_eff_all,df)
}
efficiency_frame <- scores_eff_all %>% select(1:3,6:8,20:22)
```


#Backup


  rollingAvg <- function(row){
    mean(filter(scores_func, scores_func$lat <= (as.numeric(row["lat"])+0.005) & scores_func$lat >= (as.numeric(row["lat"])-0.005) & scores_func$lon <= (as.numeric(row["lon"])+0.005) & scores_func$lon >= (as.numeric(row["lon"])-0.005))$eff) 
  }

rollingAvg_prox <- function(row){
  filter(scores_func, scores_func$lat <= (as.numeric(row["lat"])+0.005) & scores_func$lat >= (as.numeric(row["lat"])-0.005) & scores_func$lon <= (as.numeric(row["lon"])+0.005) & scores_func$lon >= (as.numeric(row["lon"])-0.005)) %>% select(9:19) %>% colMeans(na.rm = TRUE) %>% mean()
  }


origins_pos <- origins
scores_long_pos <-filter(scores_long,stringr::str_detect(nearest_n, 'all') & stringr::str_detect(weight, 'no'))
scores_pos <- left_join(scores_long_pos, origins_pos, by=c("fromId" = "id"), keep = FALSE)
scores_pos <- left_join(scores_pos, db_prox,  by=c("fromId" = "id"), keep = FALSE, set)


# Calulate initial efficiency for each block
scores_pos$pop_norm_squared <- 2*normalize_vec(scores_pos$pop)

#eff_score_df <- scores_pos %>% select(1,7:19)


scores_pos$eff <- (scores_pos$pop_norm + scores_pos$prox_emp) - scores_pos$score


# Create dataframe for each amenity type
scores_eff_gal <- filter(scores_pos,stringr::str_detect(type, 'gallery'))
scores_eff_lib <- filter(scores_pos,stringr::str_detect(type, 'library or archives'))
scores_eff_thea <- filter(scores_pos,stringr::str_detect(type, 'theatre/performance and concert hall'))
scores_eff_mus <- filter(scores_pos,stringr::str_detect(type, 'museum'))

# Create running efficiency scores
scores_eff_all <- data.frame(fromId=factor(),type=factor(),score=numeric(),weight=factor(),nearest_n=factor(),pop=numeric(),lat=numeric(),lon=numeric(),eff=numeric())
df_types <- list(scores_eff_gal,scores_eff_lib,scores_eff_thea,scores_eff_mus)
for(df in df_types){
  scores_func <- df
  df$eff_ravg <- apply(df,1, rollingAvg)
  apply(df,1, rollingAvg_prox) 
  scores_eff_all <- rbind(scores_eff_all,df)
}
efficiency_frame <- scores_eff_all[,c(1:3,6:12)]






## 2) Dataset Wrangling Part II (NA Insertion)

Each origin(fromId) should have x different scores where x is defined by:

x = 4 amenity options = 4

In addition to filling the empty NA rows for included IDs, there are also IDs
that need to be re-added as not a single time was computed for these IDs.


```{r}
paste0('EFFICIENCY FRAME')

# HOW MANY ROWS TO FILL IN EFFICIENCY FRAME?
N <- uniqueN(efficiency_frame$fromId) * 4 # expected rows
paste(glue('{nrow(efficiency_frame)} of {N} rows filled ({round((nrow(efficiency_frame) / N)*100, 2)}%)'))
paste(N - nrow(efficiency_frame), 'to fill.')

cat(paste0('\n')) # line break

# HOW MANY ROWS TO ADD IN EFFICIENCY FRAME?
# existing IDs that weren't included in ttm
missing_blocks <- array(setdiff(origins$id, efficiency_frame$fromId))
total_expected <- nrow(efficiency_frame) + length(missing_blocks) * 4 # only 4 values per origin
paste(glue('{nrow(efficiency_frame)} of {total_expected} rows filled ({round((nrow(efficiency_frame) / total_expected)*100, 2)}%)'))
paste(length(missing_blocks)*4, 'to add')
```

```{r}

x <- 4

# fill NA for all existing origin IDs
filled_efficiency_frame <- NA_table_filler_eff(efficiency_frame)
# add missing NAs to efficiency frame
all_efficiency_frame <- NA_table_filler_eff(filled_efficiency_frame,
                                       custom_idx = missing_blocks)

```

```{r}

# check efficiency
# there should be 32 counts per fromId
eff_id_counts <- all_efficiency_frame %>% group_by(fromId) %>% summarise(n = n())
unique(eff_id_counts$n)

```


Now lets add population data to the efficiency frame

```{r}
# right join with origins to include origins without transit access

all_efficiency_frame <- right_join(all_efficiency_frame, origins, by = c('fromId' = 'id'))

```

```{r}

## Export checkpoint
write.csv(all_efficiency_frame, '../../data/efficiency/efficiency_frame.csv', row.names = FALSE)

```


### Import the dissemination block shape file
```{r}
canada_shape <- st_read("../../data/census2016_DBS_shp/DB_Van_CMA/DB_Van_CMA.shp", stringsAsFactors = FALSE)

# select a greater metropolitan area
metropolitan_area <- "Vancouver"

# filter columns and rows
vancouver_shape <- data.frame(canada_shape[which(canada_shape$CMANAME == metropolitan_area), c(1, 28)])

# id to factor
vancouver_shape$DBUID <- as.factor(vancouver_shape$DBUID)

paste('Rows = ', nrow(vancouver_shape))
head(vancouver_shape)
```


## 3) Interactive Visualization
```{r}
# join factor and geometry data 
eff_viz_frame <- left_join(vancouver_shape, all_efficiency_frame, by = c('DBUID' = 'fromId'))

# convert back to sf object
eff_viz_frame_sf <- st_as_sf(eff_viz_frame)

# convert to st object
eff_viz_frame_st <- st_transform(eff_viz_frame_sf, crs = 4326)

```



## 4) Map HTML Exports

```{r}
# exclue NA in type
type_name <- unique(eff_viz_frame_sf$type)

for (amenity in type_name) { 
  
  # 4 efficiency maps
  map_maker_efficiency(data = eff_viz_frame_st, amenity,# view_map = TRUE,
                       output_dir = '../../data/html_maps/efficiency_maps')
  map_maker_efficiency_quant(data = eff_viz_frame_st, amenity,# view_map = TRUE,
                       output_dir = '../../data/html_maps/efficiency_maps_quant')

}

```





























