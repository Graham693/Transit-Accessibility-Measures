---
title: "Network Viz"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

### Loading libraries
```{r message=FALSE, warning=FALSE, include=TRUE}

# Main
library(sf)
library(tidyverse)

# Visualization
library(leaflet)
library(mapview); mapviewOptions(platform = 'leafgl')


```



### Load Canada Shape File into R and Save Vancouver Polygons as a Checkpoint

```{r}
#eval=FALSE, include=TRUE}

# geo data
# takes a long time // see google drive for the census file
canada_dbs <- st_read("Census_DBs_2016_Digital_Cartographic.gml")

# keep Vancouver rows
van_dbs <- data.frame(canada_dbs[which(canada_dbs$CMANAME == "Vancouver"), ])

# keep the gml.id, DBUID, and geometry columns
clean_van_dbs <- van_dbs[, c(1, 2, 29)]

# convert ID to character
clean_van_dbs$DBUID <- as.character(clean_van_dbs$DBUID)

# save checkpoint (this loses the CRS information unfortunately)
#st_write(clean_van_dbs, dsn = 'Vancouver_DBs_2016_Digital_Cartographic_Polygons.gml')
```


### Load Vancouver Shape File Checkpoint (not yet functional)

```{r}
# import Vancouver polygon checkpoint (cannot recover CRS information from checkpoint)
#van_dbs <- st_read('Vancouver_DBs_2016_Digital_Cartographic_Polygons.gml')
#clean_van_dbs <- data.frame(van_dbs[, 2:4])

head(clean_van_dbs)
```

### Load Score Sets

```{r}
# Function to recursively import score sets from score set directory
import_scores <- function(path) {
  
  # Get list of files in path directory
  data_files <- list.files(path = path, recursive=T)
  
  # Function to pull file data into R
  data_puller <- function(path, file) { data <- read.csv(glue::glue('{path}/{file}')) }
  data_list <- lapply(data_files, data_puller, path = path)
  
  # Remove the '.csv' from file endings
  indx_to_keep <- nchar(data_files)-4
  names(data_list) <- mapply(substr, data_files, start = 1, stop = indx_to_keep, USE.NAMES = FALSE)
  
  # reduce to a single dataframe
  scores <- data_list %>% reduce(left_join, by = c('fromId')) 
  names(scores) <- c('fromId', names(data_list))
  
  scores
}

scores <- import_scores("../../../data/score_sets")


# convert fromId column to character
scores$fromId <- as.character(scores$fromId)

head(scores)
```

### Join the shape file IDs with the score sets

```{r}

van_dbs_scores <- left_join(clean_van_dbs, scores, by = c('DBUID' = 'fromId')) 

# convert back to sf object
van_dbs_scores_sf <- st_as_sf(van_dbs_scores)

# plot geometry shapes to make sure everything worked
plot(van_dbs_scores_sf$geometry)

```


## Visualizing in leaflet

```{r}

score_visualizer <- function(st_obj, score_col, title) {
  
  score_vec <- st_obj[[score_col]]
  
  # colour palette
  Rd2Gn <- c("#e30606", "#fd8d3c", "#ffe669", "#cdff5e", "#64ed56")
  pal_fun <- colorQuantile(palette = Rd2Gn, NULL, n = 5)
  
  # interactive popup
  p_popup <- paste0("<strong>Accessibility:</strong>", score_vec)
  
  # plot
  plot <- leaflet(st_obj) %>%
    addPolygons(
      stroke = FALSE,  # remove polygon borders
      fillColor = ~pal_fun(score_vec), # set fill colour with pallette fxn
      fillOpacity = 0.5, smoothFactor = 0.5, # aesthetics
      popup = p_popup) %>% # add message popup to each block
    addTiles() %>%
    addLegend("topright",  
              pal=pal_fun, # palette function
              values=~score_vec,  # value to be passed to palette function
              title = title) # legend title
  plot
}


```

```{r}
# leaflet requires the sf object be reprojected
van_dbs_scores_st <- st_transform(van_dbs_scores_sf, crs = 4326)

# score column names
score.names <- names(van_dbs_scores_sf)[3:12]

# title names
title.vec <- score.names  %>% 
  str_replace_all('_', ' ') %>% 
  str_replace_all('  ', ' ') %>% 
  str_replace_all(' scores', '') %>% 
  str_replace_all('1', '') %>% 
  str_replace_all('3', ' 3') %>% 
  str_replace_all('destination', 'Cultural Amenities') %>% 
  str_replace_all('simulated weighted', '(weighted)') %>% 
  str_to_title() %>% 
  str_replace_all('O', 'o')


map_collection <- NULL

for (i in 1:length(score.names)) {
  temp_map <- score_visualizer(st_obj = van_dbs_scores_st,
                               score_col = score.names[i],
                               title = title.vec[i])
  
  mapshot(temp_map, url = paste0(getwd(), glue::glue("/{title.vec[i]}.html")))
  
  map_collection[i] <- temp_map
}


```









































